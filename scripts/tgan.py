#!/usr/bin/env python3
import json
import sys
from io import StringIO
from typing import Optional, Tuple

import pandas as pd

# cat payload.json | python tgan.py --n 500 --target total
# Get-Content payload.json | python tgan.py --n 500 --target total


def parse_payload_to_dataframe(raw_payload: str) -> Tuple[pd.DataFrame, dict]:
    cleaned_payload = raw_payload.strip()
    if not cleaned_payload:
        return pd.DataFrame(), {}

    try:
        parsed = json.loads(cleaned_payload)
        if isinstance(parsed, dict) and {"columns", "rows"}.issubset(parsed.keys()):
            df = pd.DataFrame(parsed.get("rows", []), columns=parsed.get("columns", []))
            config = parsed.get("config", {}) if isinstance(parsed.get("config", {}), dict) else {}
            return df, config
    except json.JSONDecodeError:
        pass

    if cleaned_payload.startswith("{") or cleaned_payload.startswith("["):
        return pd.read_json(StringIO(cleaned_payload)), {}

    return pd.read_csv(StringIO(cleaned_payload)), {}


def synthesize_with_tabular_gan(
    df: pd.DataFrame,
    n_rows: int = 0,
    target_column: Optional[str] = None,
    n_units_latent: int = 128,
) -> pd.DataFrame:
    """Generate synthetic data using SynthCity core model TabularGAN.

    Docs: synthcity.plugins.core.models.tabular_gan.TabularGAN

    Notes:
    - If target_column is provided, it is used as a conditioning variable:
      the model is trained on X=df.drop(target) with cond=df[target], and
      new rows are generated by sampling cond values from the real target.
    """
    if df is None or df.empty:
        return pd.DataFrame()

    n = n_rows if n_rows and n_rows > 0 else len(df)

    from synthcity.plugins.core.models.tabular_gan import TabularGAN

    if target_column:
        if target_column not in df.columns:
            raise ValueError(f"target_column '{target_column}' not found in columns: {list(df.columns)}")

        y = df[target_column]
        X = df.drop(columns=[target_column])

        model = TabularGAN(X=X, n_units_latent=n_units_latent, random_state=0)
        model.fit(X=X, cond=y)

        cond_gen = y.sample(n=n, replace=True, random_state=0).reset_index(drop=True)
        syn_X = model.generate(count=n, cond=cond_gen)

        syn_df = syn_X.reset_index(drop=True)
        syn_df[target_column] = cond_gen.values
        return syn_df

    model = TabularGAN(X=df, n_units_latent=n_units_latent, random_state=0)
    model.fit(X=df)
    return model.generate(count=n)


def main() -> None:
    sys.stdout.reconfigure(encoding="utf-8")
    sys.stderr.reconfigure(encoding="utf-8")

    n_rows = 0
    target_col: Optional[str] = None

    args = sys.argv[1:]
    if "--n" in args:
        i = args.index("--n")
        if i + 1 >= len(args):
            raise ValueError("Missing value after --n")
        n_rows = int(args[i + 1])

    if "--target" in args:
        i = args.index("--target")
        if i + 1 >= len(args):
            raise ValueError("Missing value after --target")
        target_col = args[i + 1]

    raw_payload = sys.stdin.read()
    df, config = parse_payload_to_dataframe(raw_payload)

    if config:
        n_rows = int(config.get("n", n_rows) or 0)
        target_col = config.get("target") or target_col

    try:
        syn_df = synthesize_with_tabular_gan(df, n_rows=n_rows, target_column=target_col)

        response = {
            "status": "ok",
            "message": "Синтез выполнен успешно",
            "rows_real": int(len(df)),
            "rows_synth": int(len(syn_df)),
            "data_synth": syn_df.to_dict(orient="records"),
        }
        print(json.dumps(response, ensure_ascii=False))

    except Exception as e:
        response = {
            "status": "error",
            "message": "Ошибка синтеза данных",
            "error": str(e),
        }
        print(json.dumps(response, ensure_ascii=False))
        raise


if __name__ == "__main__":
    main()
